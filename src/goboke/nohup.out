[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<nil>
[GIN] 2022/01/09 - 21:42:11 | 200 |     417.746µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/09 - 21:42:19 | 200 |     335.932µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/09 - 21:42:20 | 200 |      334.35µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 09:59:28 | 200 |     542.101µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 09:59:39 | 200 |     325.813µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 10:00:07 | 200 |     349.618µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 10:08:19 | 200 |     592.196µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 21:12:29 | 200 |   41.932859ms | 113.118.101.234 | POST     "/common/getTechnologyShare"
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] POST   /common/getDetail         --> main.main.func6 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:40 | 200 |    1.846106ms | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:41 | 200 |     682.454µs | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:50 | 200 |     1.94424ms | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:52:23 | 200 |    1.763811ms | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 21:52:55 | 200 |     363.674µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 21:53:11 | 200 |     321.845µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:53:16 | 200 |    2.399066ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:55:29 | 200 |   11.615377ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:56:18 | 200 |      557.48µs | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:02:34 | 200 |  124.997954ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:03:17 | 200 | 12.784486278s | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:14:01 | 200 |   39.877699ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:14:10 | 200 |     565.965µs | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:14:11 | 200 |     358.235µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 22:14:12 | 200 |    1.812272ms | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:19:34 | 200 |     613.326µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:19:34 | 200 |     556.157µs | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:19:38 | 200 |     372.681µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:19:40 | 200 |     567.498µs | 113.118.101.234 | POST     "/common/getDetail"
