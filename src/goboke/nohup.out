[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<nil>
[GIN] 2022/01/09 - 21:42:11 | 200 |     417.746µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/09 - 21:42:19 | 200 |     335.932µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/09 - 21:42:20 | 200 |      334.35µs | 113.118.113.111 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 09:59:28 | 200 |     542.101µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 09:59:39 | 200 |     325.813µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 10:00:07 | 200 |     349.618µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 10:08:19 | 200 |     592.196µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 21:12:29 | 200 |   41.932859ms | 113.118.101.234 | POST     "/common/getTechnologyShare"
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] POST   /common/getDetail         --> main.main.func6 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:40 | 200 |    1.846106ms | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:41 | 200 |     682.454µs | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:51:50 | 200 |     1.94424ms | 113.118.101.234 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 21:52:23 | 200 |    1.763811ms | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 21:52:55 | 200 |     363.674µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/10 - 21:53:11 | 200 |     321.845µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:53:16 | 200 |    2.399066ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:55:29 | 200 |   11.615377ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 21:56:18 | 200 |      557.48µs | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:02:34 | 200 |  124.997954ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:03:17 | 200 | 12.784486278s | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:14:01 | 200 |   39.877699ms | 113.118.101.234 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:14:10 | 200 |     565.965µs | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:14:11 | 200 |     358.235µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/10 - 22:14:12 | 200 |    1.812272ms | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:19:34 | 200 |     613.326µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:19:34 | 200 |     556.157µs | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/10 - 22:19:38 | 200 |     372.681µs | 113.118.101.234 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/10 - 22:19:40 | 200 |     567.498µs | 113.118.101.234 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 15:08:18 | 200 |    1.939179ms |   113.108.77.53 | POST     "/common/getTechnologyShare"
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] POST   /common/getDetail         --> main.main.func6 (4 handlers)
[GIN-debug] POST   /common/updateTechnologyShare --> main.main.func7 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
[GIN-debug] [ERROR] listen tcp :3332: bind: address already in use
<nil>
[GIN] 2022/01/11 - 15:29:24 | 200 |     633.332µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:31:32 | 200 |     345.542µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:42:24 | 200 |     595.321µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:42:25 | 200 |     309.693µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] POST   /common/getDetail         --> main.main.func6 (4 handlers)
[GIN-debug] POST   /common/updateTechnologyShare --> main.main.func7 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<nil>
[GIN] 2022/01/11 - 15:50:17 | 200 |     430.711µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:50:18 | 200 |     340.391µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<p>dasdassa</p>
<nil>
[GIN] 2022/01/11 - 15:50:19 | 200 |      595.44µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 15:50:21 | 200 |     339.308µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:50:28 | 200 |     337.094µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:50:29 | 200 |     377.302µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:50:34 | 200 |     378.593µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 15:52:16 | 200 |     376.519µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/11 - 16:04:39 | 200 |    1.610921ms |   113.108.77.53 | POST     "/common/getDetail"
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /common/login             --> main.main.func1 (4 handlers)
[GIN-debug] POST   /common/submit            --> main.main.func2 (4 handlers)
[GIN-debug] POST   /common/read              --> main.main.func3 (4 handlers)
[GIN-debug] POST   /common/getTechnologyShare --> main.main.func4 (4 handlers)
[GIN-debug] POST   /common/addTechnologyShare --> main.main.func5 (4 handlers)
[GIN-debug] POST   /common/getDetail         --> main.main.func6 (4 handlers)
[GIN-debug] POST   /common/updateTechnologyShare --> main.main.func7 (4 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :3332
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/11 - 16:17:50 | 200 |     889.173µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 16:21:16 | 200 |     571.547µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/01/11 - 16:21:18 | 200 |    1.260913ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 16:21:21 | 200 |     336.714µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/01/11 - 16:21:22 | 200 |     1.36018ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 16:21:25 | 200 |     345.851µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/01/11 - 16:21:29 | 200 |     531.069µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 16:21:32 | 200 |     332.637µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/11 - 17:06:19 | 200 |     587.476µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/11 - 17:06:21 | 200 |     675.862µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 17:24:43 | 200 |    1.862815ms |   113.108.77.53 | POST     "/common/getTechnologyShare"
{谈谈IntersectionObserver懒加载 azjfeng IntersectionObserver接口(从属于Intersection Observer API)为开发者提供了一种可以异步监听目标元素与其祖先或视窗(viewport)交叉状态的手段。祖先元素与视窗(viewport)被称为根(root)。  <pre><code>const io = new IntersectionObserver(()=&gt;{ // 实例化 默认基于当前视窗
    
})  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>}
2022/01/11 17:40:58
{0xc00030ec60 0xc000273ea0}
[GIN] 2022/01/11 - 17:40:58 | 200 |    5.032022ms |   113.108.77.53 | POST     "/common/addTechnologyShare"
<nil>
[GIN] 2022/01/11 - 17:41:03 | 200 |     352.243µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(()=&gt;{ // 实例化 默认基于当前视窗
    
})  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:41:08 | 200 |    1.685353ms |   113.108.77.53 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(()=&gt;{ // 实例化 默认基于当前视窗
    
})  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:45:41 | 200 |     740.995µs |   113.108.77.53 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(()=&gt;{ // 实例化 默认基于当前视窗
    
})  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:47:09 | 200 |      520.38µs |   113.108.77.53 | POST     "/common/getDetail"
[GIN] 2022/01/11 - 17:47:59 | 200 |    4.846312ms |   113.108.77.53 | POST     "/common/updateTechnologyShare"
<nil>
[GIN] 2022/01/11 - 17:48:03 | 200 |     357.514µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:48:04 | 200 |     504.439µs |   113.108.77.53 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:48:28 | 200 |     514.658µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 17:48:32 | 200 |     351.151µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:48:33 | 200 |     590.041µs |   113.108.77.53 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:59:33 | 200 |     832.266µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 17:59:35 | 200 |     383.512µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 17:59:41 | 200 |     495.783µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 17:59:46 | 200 |     342.836µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 19:00:40 | 200 |     734.633µs |   113.108.77.53 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 19:01:20 | 200 |     524.358µs |   113.108.77.58 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 19:02:59 | 200 |     534.096µs |   113.108.77.58 | POST     "/common/getDetail"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/11 - 19:10:24 | 200 |       754.8µs |   113.108.77.55 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 19:10:31 | 200 |     354.027µs |   113.108.77.55 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/11 - 19:10:36 | 200 |     523.456µs |   113.108.77.55 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 19:10:44 | 200 |     345.029µs |   113.108.77.55 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/11 - 19:10:46 | 200 |     500.962µs |   113.108.77.55 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/11 - 19:10:49 | 200 |     351.292µs |   113.108.77.55 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/11 - 19:10:51 | 200 |     503.428µs |   113.108.77.55 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 09:33:54 | 200 |     611.361µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/12 - 09:37:09 | 200 |     745.524µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 09:37:56 | 200 |     383.933µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/12 - 10:23:27 | 200 |     801.379µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 10:23:32 | 200 |     341.072µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/12 - 10:23:33 | 200 |     524.317µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 10:23:49 | 200 |     355.539µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/12 - 10:23:50 | 200 |     715.637µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 10:24:27 | 200 |     356.611µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/12 - 11:07:10 | 200 |     737.098µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 11:07:15 | 200 |     329.972µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/12 - 17:36:12 | 200 |     795.046µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:15 | 200 |     346.852µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/12 - 17:36:16 | 200 |     505.731µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:20 | 200 |     329.651µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/12 - 17:36:21 | 200 |     517.745µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:27 | 200 |     350.881µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/12 - 17:36:28 | 200 |     494.391µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:30 | 200 |     353.905µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/01/12 - 17:36:31 | 200 |     564.413µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:34 | 200 |     327.846µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/12 - 17:36:36 | 200 |     672.377µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/12 - 17:36:38 | 200 |     334.099µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/01/13 - 11:11:29 | 200 |     767.073µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/13 - 11:11:33 | 200 |     361.571µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/13 - 11:11:34 | 200 |      505.02µs |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/13 - 11:11:36 | 200 |     317.347µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/13 - 19:02:58 | 200 |     581.465µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/01/15 - 14:31:43 | 200 |     617.693µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
{初探虚拟dom jameinfeng 虚拟dom原理是利用dom api将真实节点转换成JSON格式得数据，当数据发生变化时对比新旧JSON进行dom操作 <h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>}
2022/01/15 14:38:01
{0xc000414bd0 0xc00041c560}
[GIN] 2022/01/15 - 14:38:02 | 200 |  177.053795ms |   113.108.77.53 | POST     "/common/addTechnologyShare"
<nil>
[GIN] 2022/01/15 - 14:38:09 | 200 |     353.174µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/15 - 14:38:13 | 200 |    1.264419ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/15 - 14:39:49 | 200 |     353.204µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/15 - 14:40:58 | 200 |     549.444µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/17 - 16:30:31 | 200 |      717.25µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/17 - 16:30:37 | 200 |     523.396µs |   113.108.77.53 | POST     "/common/getDetail"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/17 - 16:30:54 | 200 |     519.599µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/17 - 16:32:25 | 200 |     336.244µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/17 - 16:32:27 | 200 |     549.693µs |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/17 - 16:32:30 | 200 |     624.226µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:43:53 | 200 |    1.744694ms |   113.108.77.60 | POST     "/common/getDetail"
<h3 id="t2yj2">1.如何将真实节点转换成json格式得数据</h3><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" && name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:43:58 | 200 |     586.573µs |   113.108.77.60 | POST     "/common/getDetail"
[GIN] 2022/01/18 - 09:50:54 | 200 |    5.717462ms |   113.108.77.60 | POST     "/common/updateTechnologyShare"
<nil>
[GIN] 2022/01/18 - 09:51:00 | 200 |     386.057µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp><font color="#8baa4a">function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</font></xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:51:02 | 200 |    2.403093ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/18 - 09:51:08 | 200 |     348.025µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/01/18 - 09:51:08 | 200 |   12.726014ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/18 - 09:51:10 | 200 |     325.362µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/01/18 - 09:51:11 | 200 |   14.561991ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/18 - 09:51:13 | 200 |     365.849µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp><font color="#8baa4a">function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</font></xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:51:14 | 200 |     545.337µs |   113.108.77.60 | POST     "/common/getDetail"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp><font color="#8baa4a">function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</font></xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:51:23 | 200 |     548.482µs |   113.108.77.60 | POST     "/common/getDetail"
[GIN] 2022/01/18 - 09:51:35 | 200 |   16.603574ms |   113.108.77.60 | POST     "/common/updateTechnologyShare"
<nil>
[GIN] 2022/01/18 - 09:51:37 | 200 |     364.366µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/01/18 - 09:51:39 | 200 |     564.363µs |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/01/18 - 10:07:31 | 200 |    1.270081ms |   113.108.77.60 | POST     "/common/getTechnologyShare"
[GIN] 2022/01/28 - 03:58:25 | 404 |       11.01µs |  150.138.73.114 | GET      "/1.txt"
[GIN] 2022/01/28 - 15:45:19 | 404 |      30.958µs |   101.227.1.198 | GET      "/"
[GIN] 2022/01/28 - 15:45:20 | 404 |       3.356µs |   101.227.1.198 | GET      "/favicon.ico"
<nil>
[GIN] 2022/02/08 - 14:27:49 | 200 |    3.472537ms |   113.108.77.67 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/02/08 - 14:27:57 | 200 |   35.374813ms |   113.108.77.67 | POST     "/common/getDetail"
<nil>
[GIN] 2022/02/08 - 14:28:15 | 200 |     979.193µs |   113.108.77.67 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/02/08 - 14:28:17 | 200 |   17.021662ms |   113.108.77.67 | POST     "/common/getDetail"
<nil>
[GIN] 2022/02/24 - 11:30:03 | 200 |   65.029988ms |   113.108.77.60 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/02/24 - 11:30:26 | 200 |   67.985992ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/02/24 - 11:30:31 | 200 |     327.526µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/02/24 - 11:30:32 | 200 |    36.04305ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/02/24 - 11:30:36 | 200 |     343.556µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:30:42 | 200 |     328.909µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:30:45 | 200 |     362.943µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:30:46 | 200 |     340.582µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:30:47 | 200 |     326.905µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:30:54 | 200 |     387.038µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/02/24 - 11:31:05 | 200 |     972.772µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/09 - 14:42:54 | 200 |     2.51173ms |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/03/09 - 14:43:03 | 200 |   13.469249ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/09 - 14:43:44 | 200 |    2.038469ms |   113.108.77.60 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/09 - 14:43:53 | 200 |   44.509632ms |   113.108.77.60 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/09 - 14:43:57 | 200 |     325.733µs |   113.108.77.60 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:09:07 | 200 |  158.049189ms |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:22:03 | 200 |     583.219µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:25:47 | 200 |     611.312µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:25:50 | 200 |      355.72µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/03/23 - 17:25:57 | 200 |  202.922465ms |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 17:26:00 | 200 |     342.404µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:28:14 | 200 |     394.392µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/23 - 17:28:19 | 200 |   13.601084ms |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 17:28:24 | 200 |     349.719µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:30:06 | 200 |     649.683µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:33:52 | 200 |     675.602µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:34:19 | 200 |   14.574867ms |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:34:47 | 200 |     374.275µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:34:52 | 200 |     367.032µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:37:41 | 200 |     599.649µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:37:46 | 200 |     335.883µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:38:05 | 200 |     353.295µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:41:56 | 200 |    1.244885ms |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:41:59 | 200 |     348.937µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:42:07 | 200 |     353.146µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:42:45 | 200 |     347.214µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:42:47 | 200 |      350.51µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:42:49 | 200 |     395.735µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:54:46 | 200 |     582.837µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:54:48 | 200 |     341.102µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 17:54:51 | 200 |    2.084936ms |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 18:59:20 | 200 |     897.499µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 18:59:31 | 200 |     337.685µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/03/23 - 18:59:53 | 200 |   22.193736ms |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 18:59:55 | 200 |     367.102µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 18:59:56 | 200 |    1.409896ms |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 19:00:24 | 200 |     324.551µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:01:28 | 200 |     376.589µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:02:36 | 200 |     611.871µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:02:38 | 200 |     512.055µs |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:08:45 | 200 |     756.285µs |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:09:15 | 200 |      509.49µs |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 19:09:20 | 200 |     369.285µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:10:45 | 200 |      366.04µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:10:47 | 200 |     506.524µs |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 19:10:54 | 200 |     344.639µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:11:36 | 200 |     358.095µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:11:38 | 200 |     344.939µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:11:40 | 200 |       494.2µs |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:12:31 | 200 |    1.506688ms |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:12:34 | 200 |     602.024µs |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:12:35 | 200 |     566.045µs |   113.108.77.72 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:12:37 | 200 |     474.885µs |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/23 - 19:12:41 | 200 |     367.943µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/23 - 19:12:46 | 200 |     345.491µs |   113.108.77.72 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/23 - 19:12:48 | 200 |     493.429µs |   113.108.77.72 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 08:52:30 | 200 |     594.929µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 08:55:40 | 200 |     793.665µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 08:59:48 | 200 |    1.211962ms |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/24 - 09:00:20 | 200 |     341.673µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/24 - 09:01:20 | 200 |      371.06µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/24 - 09:02:09 | 200 |     911.908µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/24 - 09:02:14 | 200 |     352.454µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:02:15 | 200 |     525.058µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:08:29 | 200 |     736.237µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:08:34 | 200 |    1.096815ms |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:08:49 | 200 |      519.95µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:09:17 | 200 |    4.672448ms |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:09:20 | 200 |     491.395µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:09:40 | 200 |     493.299µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:09:45 | 200 |     527.754µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:09:47 | 200 |     503.367µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:10:29 | 200 |    7.092174ms |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:10:33 | 200 |     501.906µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:11:52 | 200 |     772.244µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:15:59 | 200 |    1.405085ms |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:16:41 | 200 |     564.995µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:16:42 | 200 |     468.612µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:16:44 | 200 |     480.205µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:16:50 | 200 |     360.349µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:16:53 | 200 |     515.661µs |   113.108.77.66 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:18:17 | 200 |    1.265943ms |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:18:24 | 200 |     357.303µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:18:25 | 200 |      647.96µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:18:31 | 200 |     351.041µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:18:32 | 200 |     564.174µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:18:34 | 200 |     367.662µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:18:35 | 200 |   23.348083ms |   113.108.77.66 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:18:49 | 200 |     641.238µs |   113.108.77.66 | POST     "/common/getDetail"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:19:33 | 200 |     917.938µs |   113.108.77.66 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:20:00 | 200 |     665.464µs |   113.108.77.66 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:20:02 | 200 |     634.715µs |   113.108.77.66 | POST     "/common/getDetail"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:20:21 | 200 |    1.293156ms |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:20:28 | 200 |     394.773µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/24 - 09:20:37 | 200 |      356.37µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:20:38 | 200 |     553.542µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:21:14 | 200 |       414.2µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:22:28 | 200 |    1.361574ms |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:22:57 | 200 |     672.566µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:22:59 | 200 |     495.023µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:23:02 | 200 |     335.673µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:23:03 | 200 |     625.948µs |   113.108.77.66 | POST     "/common/getDetail"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:23:07 | 200 |     553.252µs |   113.108.77.66 | POST     "/common/getDetail"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 09:23:17 | 200 |    5.414394ms |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:23:19 | 200 |     342.356µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/03/24 - 09:23:23 | 200 |     741.226µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 09:23:27 | 200 |     336.003µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/24 - 09:23:44 | 200 |     609.657µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 10:06:15 | 200 |     858.195µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/03/24 - 10:06:19 | 200 |     563.712µs |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 10:14:09 | 200 |    1.527034ms |   113.108.77.66 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/03/24 - 10:14:31 | 200 |   11.223674ms |   113.108.77.66 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/24 - 10:14:40 | 200 |     338.557µs |   113.108.77.66 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/26 - 03:33:08 | 200 |     601.833µs |  183.240.132.44 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/26 - 03:33:42 | 200 |     346.081µs |  183.240.132.44 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/30 - 15:52:22 | 200 |   22.363592ms |    66.249.73.14 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/30 - 16:17:50 | 200 |     691.621µs | 113.204.115.245 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/30 - 16:17:50 | 200 |     314.962µs | 113.204.115.245 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/30 - 16:17:50 | 200 |     326.114µs | 113.204.115.245 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/31 - 19:24:09 | 200 |     899.534µs |   113.108.77.57 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/03/31 - 19:24:17 | 200 |   23.197031ms |   113.108.77.57 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/31 - 19:24:19 | 200 |      339.64µs |   113.108.77.57 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/03/31 - 19:24:20 | 200 |   27.512023ms |   113.108.77.57 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/31 - 19:24:23 | 200 |     358.946µs |   113.108.77.57 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/03/31 - 19:24:30 | 200 |     338.919µs |   113.108.77.57 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/03/31 - 19:24:32 | 200 |   16.419056ms |   113.108.77.57 | POST     "/common/getDetail"
<nil>
[GIN] 2022/03/31 - 19:24:42 | 200 |     345.139µs |   113.108.77.57 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/03/31 - 19:24:44 | 200 |   35.844966ms |   113.108.77.57 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/07 - 02:22:36 | 200 |     658.621µs |   66.249.70.115 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/07 - 13:11:15 | 200 |    1.362204ms |   103.146.78.75 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/07 - 17:00:11 | 200 |     577.688µs |   66.249.70.117 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/08 - 19:48:24 | 200 |     651.657µs |  18.119.122.111 | POST     "/common/getTechnologyShare"
[GIN] 2022/04/08 - 22:59:25 | 404 |       3.035µs |  45.115.126.250 | GET      "/common/template/lottery/lecai/css/style.css"
[GIN] 2022/04/10 - 22:19:43 | 404 |      31.119µs |   40.77.189.123 | GET      "/common/getTechnologyShare"
[GIN] 2022/04/10 - 22:19:43 | 404 |       2.996µs |    40.77.188.32 | GET      "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/11 - 00:25:40 | 200 |     656.777µs |    66.249.77.51 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/11 - 03:22:25 | 200 |     581.475µs |    66.249.77.51 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:14:40 | 200 |     622.822µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:14:47 | 200 |   66.371407ms |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:15:04 | 200 |    4.320497ms |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/04/14 - 11:15:05 | 200 |   57.155077ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/14 - 11:15:07 | 200 |     345.863µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:16:00 | 200 |     338.037µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:16:54 | 200 |     1.36952ms |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:18:02 | 200 |     606.984µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:20:45 | 200 |     356.071µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:21:59 | 200 |     694.047µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:30:29 | 200 |     627.332µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:30:36 | 200 |     352.593µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:32:20 | 200 |     550.416µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/04/14 - 11:32:30 | 200 |   34.619632ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/14 - 11:32:37 | 200 |     338.096µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h2>父组件向子组件通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br/>
下面是演示代码：<br/>
父组件 App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{

    render(){
        return(
            &lt;div&gt;
                &lt;Sub title = "今年过节不收礼" /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>子组件 SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    return(
        &lt;h1&gt;
            { props.title }
        &lt;/h1&gt;
    )
}

export default Sub;</code></pre><h2>子组件向父组件通信</h2><p>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br/>
下面是演示代码：<br/>
SubComponent.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";

const Sub = (props) =&gt; {
    const cb = (msg) =&gt; {
        return () =&gt; {
            props.callback(msg)
        }
    }
    return(
        &lt;div&gt;
            &lt;button onClick = { cb("我们通信把") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Sub;
</code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import Sub from "./SubComponent.js";
import "./App.css";

export default class App extends Component{
    callback(msg){
        console.log(msg);
    }
    render(){
        return(
            &lt;div&gt;
                &lt;Sub callback = { this.callback.bind(this) } /&gt;
            &lt;/div&gt;
        )
    }
}</code></pre><p>



<br/></p><h2>级组件通信</h2><p>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p><ul>
<li>中间组件层层传递 props</li>
<li>使用 context 对象</li>
</ul><p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。<br/>
使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。<br/>
使用 context 也很简单，需要满足两个条件：</p><ul>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</li>
<li>子组件要声明自己需要使用 context</li>
</ul><p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br/>
App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:"red",
            callback:this.callback.bind(this)
        }
    }

    callback(msg){
        console.log(msg)
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Sub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React from "react";
import SubSub from "./SubSub";

const Sub = (props) =&gt;{
    return(
        &lt;div&gt;
            &lt;SubSub /&gt;
        &lt;/div&gt;
    );
}

export default Sub;
</code></pre><p>SubSub.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

export default class SubSub extends Component{
    // 子组件声明自己需要使用 context
    static contextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }
    render(){
        const style = { color:this.context.color }
        const cb = (msg) =&gt; {
            return () =&gt; {
                this.context.callback(msg);
            }
        }
        return(
            &lt;div style = { style }&gt;
                SUBSUB
                &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>









<br/></p><p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。<br/>
在使用 context 时，有两点需要注意：</p><ul>
<li>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</li>
<li>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</li>
<li>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</li>
</ul><p><strong>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context</strong>。</p><p><button><i><path></path></i></button></p><pre><code>...
constructor(props,context){
  super(props,context);
}
...
</code></pre><h3>改变 context 对象</h3><p>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，<strong>只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象</strong>，而后子组件进行相应的渲染。<br/>
修改 App.js，让 context 对象可变：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';
import PropTypes from "prop-types";
import Sub from "./Sub";
import "./App.css";

export default class App extends Component{
    constructor(props) {
        super(props);
        this.state = {
            color:"red"
        };
    }
    // 父组件声明自己支持 context
    static childContextTypes = {
        color:PropTypes.string,
        callback:PropTypes.func,
    }

    // 父组件提供一个函数，用来返回相应的 context 对象
    getChildContext(){
        return{
            color:this.state.color,
            callback:this.callback.bind(this)
        }
    }

    // 在此回调中修改父组件的 state
    callback(color){
        this.setState({
            color,
        })
    }

    render(){
        return(
            &lt;div&gt;
                &lt;Sub&gt;&lt;/Sub&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p><p><button><i><path></path></i></button></p><pre><code>...
return(
    &lt;div style = { style }&gt;
        SUBSUB
        &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
    &lt;/div&gt;
);
...
</code></pre><p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import PropTypes from "prop-types";

const SubSub = (props,context) =&gt; {
    const style = { color:context.color }
    const cb = (msg) =&gt; {
        return () =&gt; {
            context.callback(msg);
        }
    }

    return(
        &lt;div style = { style }&gt;
            SUBSUB
            &lt;button onClick = { cb("我胡汉三又回来了！") }&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    );
}

SubSub.contextTypes = {
    color:PropTypes.string,
    callback:PropTypes.func,
}

export default SubSub;</code></pre><p>









<br/></p><h2>非嵌套组件间通信</h2><p>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p><ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>使用自定义事件的方式</li>
</ul><p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以...<br/>
这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br/>
我们需要使用一个 events 包：</p><p><button><i><path></path></i></button></p><pre><code>npm install events --save</code></pre><p>



<br/>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：<br/></p><pre><code class="Markdown"><xmp>import { EventEmitter } from "events";
export default new EventEmitter();</xmp></code></pre><p>App.js：</p><p><button><i><path></path></i></button></p><pre><code>import React, { Component } from 'react';

import Foo from "./Foo";
import Boo from "./Boo";

import "./App.css";

export default class App extends Component{
    render(){
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    }
} 
</code></pre><p>Foo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Foo extends Component{
    constructor(props) {
        super(props);
        this.state = {
            msg:null,
        };
    }
    componentDidMount(){
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener("callMe",(msg)=&gt;{
            this.setState({
                msg
            })
        });
    }
    // 组件销毁前移除事件监听
    componentWillUnmount(){
        emitter.removeListener(this.eventEmitter);
    }
    render(){
        return(
            &lt;div&gt;
                { this.state.msg }
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    }
}
</code></pre><p>Boo.js：</p><p><button><i><path></path></i></button></p><pre><code>import React,{ Component } from "react";
import emitter from "./ev"

export default class Boo extends Component{
    render(){
        const cb = (msg) =&gt; {
            return () =&gt; {
                // 触发自定义事件
                emitter.emit("callMe","Hello")
            }
        }
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = { cb("blue") }&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p><h2>总结</h2><p>本文总结了 React 中组件的几种通信方式，分别是：</p><ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul><p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。<br/>
当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<nil>
[GIN] 2022/04/14 - 11:32:39 | 200 |   13.721101ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/14 - 11:32:52 | 200 |     346.202µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/04/14 - 11:32:53 | 200 |   14.419548ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/14 - 11:33:06 | 200 |     328.458µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:44:46 | 200 |     627.782µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
{   <p>😁<br/></p>}
2022/04/14 11:45:02
{0xc0000d0120 0xc00041c3a0}
[GIN] 2022/04/14 - 11:45:02 | 200 |   54.210488ms |   113.108.77.53 | POST     "/common/addTechnologyShare"
{   <p>😞<br/></p>}
2022/04/14 11:45:12
{0xc0000d0120 0xc00041c510}
[GIN] 2022/04/14 - 11:45:12 | 200 |    6.219303ms |   113.108.77.53 | POST     "/common/addTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:45:19 | 200 |     353.957µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:45:29 | 200 |      345.48µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 11:47:54 | 200 |     603.697µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<pre><code>const io = new IntersectionObserver(callback)  

let ings = document.querySelectorAll('[data-src]') // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src

function callback(entries){  
    entries.forEach((item) =&gt; { // 遍历entries数组
        if(item.isIntersecting){ // 当前元素可见
            item.target.src = item.target.dataset.src  // 替换src
            io.unobserve(item.target)  // 停止观察当前元素 避免不可见时候再次调用callback函数
        }   
    })
}

imgs.forEach((item)=&gt;{  // io.observe接受一个DOM元素，添加多个监听 使用forEach
    io.observe(item)
})
   </code></pre>
<nil>
[GIN] 2022/04/14 - 11:47:56 | 200 |   13.994985ms |   113.108.77.53 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/14 - 11:47:57 | 200 |     365.898µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:26:15 | 200 |     597.856µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:42:07 | 200 |     590.792µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:42:09 | 200 |      349.81µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:47:01 | 200 |     876.802µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:49:16 | 200 |     654.693µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:49:18 | 200 |     334.419µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/14 - 14:49:20 | 200 |     349.167µs |   113.108.77.53 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:17:18 | 200 |   39.169584ms |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:20:53 | 200 |     649.532µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:21:45 | 200 |     951.241µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:25:33 | 200 |     715.968µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:32:25 | 200 |     567.779µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
{github webHooks jameinfeng 如何利用github 实现CI/CD <h2 id="yhxvr">1. 搭建服务端</h2><p>&nbsp; &nbsp; &nbsp; 可以利用nginx加上node和koa实现一个小型服务端</p><pre><code class="JavaScript">const Koa = require('koa');
const app = new Koa();
const Router = require('koa-router');
const router = new Router();
const koaBody = require('koa-body');
const path = require('path')
app.use(koaBody({
    multipart: true, // 支持文件上传
    formidable: {
        uploadDir: path.join(__dirname, 'public/upload/'), // 设置文件上传目录
        keepExtensions: true,    // 保持文件的后缀
        maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
        onFileBegin: (name, file) =&gt; { // 文件上传前的设置
            // console.log(`name: ${name}`);
            // console.log(file);
        },
    }
}));

<font color="#1c487f">const exec = require('child_process').exec;</font>

let temp = process.env,
    environment = {};
environment.PATH = temp.PATH + ":/usr/local/node/bin";
const option = {
    env: environment
}
console.log(process.platform)

router.post('/api/gitpull', async (ctx, next) =&gt; {
    try {
        const params = JSON.parse(ctx.request.body.payload)             //获取github请求参数
        const { repository: { clone_url, full_name } } = params         //获取项目路径和项目名
        const projectName = full_name.split("/")[1]
        const cmdStr = process.platform.indexOf('win') !== -1 ? `./index.sh ${projectName} ${clone_url}` : `sh ./index.sh ${projectName} ${clone_url}`
        exec(cmdStr, option, function (err, stdout, stderr) {
            if (err) {
                console.log('get weather api error:' + stderr);
            } else {
                console.log("更新代码成功")
            }
        });
        ctx.body = 'dddd'
    } catch (error) {
        console.log(error)
    }
    // await ctx.render('index');
})

app.use(router.routes()).use(router.allowedMethods());

app.listen('5555', () =&gt; {
    console.log('http://127.0.0.1:5555')
})</code></pre><p><font color="#f9963b">当我们提交代码是触发相应的hooks，然后再我们的请求接口中利用child_process模块</font></p><p><font color="#f9963b">去执行shell脚本做到自动拉取代码</font></p><h2 id="f43n1">2. 利用上述接口在相应得git项目中设置hooks钩子</h2><p>&nbsp; &nbsp;&nbsp;<br/></p><img src="https://www.azjfeng.com/static/hooks.png" contenteditable="false"/><h2 id="ns24d">3. 编写对应得shell脚本</h2><p><font color="#f9963b">&nbsp; &nbsp; $1 对应项目名 $2对应git地址</font><br/></p><pre><code class="Bash">#!/bin/bash

echo "/data/home/git/$1"
url = "/data/home/git/$1"
if [ ! -f $url ];then
    echo "文件不存在"
    cd /data/home/git/
    git clone "$2"
else
    echo '$1'
    cd /data/home/git/"$1"
    git pull
fi</code></pre>}
2022/04/15 15:38:30
{0xc0000d0120 0xc00041c160}
[GIN] 2022/04/15 - 15:38:30 | 200 |    7.621273ms |   113.108.77.58 | POST     "/common/addTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:38:37 | 200 |     381.538µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<h2 id="yhxvr">1. 搭建服务端</h2><p>&nbsp; &nbsp; &nbsp; 可以利用nginx加上node和koa实现一个小型服务端</p><pre><code class="JavaScript">const Koa = require('koa');
const app = new Koa();
const Router = require('koa-router');
const router = new Router();
const koaBody = require('koa-body');
const path = require('path')
app.use(koaBody({
    multipart: true, // 支持文件上传
    formidable: {
        uploadDir: path.join(__dirname, 'public/upload/'), // 设置文件上传目录
        keepExtensions: true,    // 保持文件的后缀
        maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
        onFileBegin: (name, file) =&gt; { // 文件上传前的设置
            // console.log(`name: ${name}`);
            // console.log(file);
        },
    }
}));

<font color="#1c487f">const exec = require('child_process').exec;</font>

let temp = process.env,
    environment = {};
environment.PATH = temp.PATH + ":/usr/local/node/bin";
const option = {
    env: environment
}
console.log(process.platform)

router.post('/api/gitpull', async (ctx, next) =&gt; {
    try {
        const params = JSON.parse(ctx.request.body.payload)             //获取github请求参数
        const { repository: { clone_url, full_name } } = params         //获取项目路径和项目名
        const projectName = full_name.split("/")[1]
        const cmdStr = process.platform.indexOf('win') !== -1 ? `./index.sh ${projectName} ${clone_url}` : `sh ./index.sh ${projectName} ${clone_url}`
        exec(cmdStr, option, function (err, stdout, stderr) {
            if (err) {
                console.log('get weather api error:' + stderr);
            } else {
                console.log("更新代码成功")
            }
        });
        ctx.body = 'dddd'
    } catch (error) {
        console.log(error)
    }
    // await ctx.render('index');
})

app.use(router.routes()).use(router.allowedMethods());

app.listen('5555', () =&gt; {
    console.log('http://127.0.0.1:5555')
})</code></pre><p><font color="#f9963b">当我们提交代码是触发相应的hooks，然后再我们的请求接口中利用child_process模块</font></p><p><font color="#f9963b">去执行shell脚本做到自动拉取代码</font></p><h2 id="f43n1">2. 利用上述接口在相应得git项目中设置hooks钩子</h2><p>&nbsp; &nbsp;&nbsp;<br/></p><img src="https://www.azjfeng.com/static/hooks.png" contenteditable="false"/><h2 id="ns24d">3. 编写对应得shell脚本</h2><p><font color="#f9963b">&nbsp; &nbsp; $1 对应项目名 $2对应git地址</font><br/></p><pre><code class="Bash">#!/bin/bash

echo "/data/home/git/$1"
url = "/data/home/git/$1"
if [ ! -f $url ];then
    echo "文件不存在"
    cd /data/home/git/
    git clone "$2"
else
    echo '$1'
    cd /data/home/git/"$1"
    git pull
fi</code></pre>
<nil>
[GIN] 2022/04/15 - 15:38:42 | 200 |     677.415µs |   113.108.77.58 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/15 - 15:39:00 | 200 |      388.01µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/15 - 15:42:20 | 200 |     1.25361ms |   113.108.77.58 | POST     "/common/getTechnologyShare"
<h2 id="yhxvr">1. 搭建服务端</h2><p>&nbsp; &nbsp; &nbsp; 可以利用nginx加上node和koa实现一个小型服务端</p><pre><code class="JavaScript">const Koa = require('koa');
const app = new Koa();
const Router = require('koa-router');
const router = new Router();
const koaBody = require('koa-body');
const path = require('path')
app.use(koaBody({
    multipart: true, // 支持文件上传
    formidable: {
        uploadDir: path.join(__dirname, 'public/upload/'), // 设置文件上传目录
        keepExtensions: true,    // 保持文件的后缀
        maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
        onFileBegin: (name, file) =&gt; { // 文件上传前的设置
            // console.log(`name: ${name}`);
            // console.log(file);
        },
    }
}));

<font color="#1c487f">const exec = require('child_process').exec;</font>

let temp = process.env,
    environment = {};
environment.PATH = temp.PATH + ":/usr/local/node/bin";
const option = {
    env: environment
}
console.log(process.platform)

router.post('/api/gitpull', async (ctx, next) =&gt; {
    try {
        const params = JSON.parse(ctx.request.body.payload)             //获取github请求参数
        const { repository: { clone_url, full_name } } = params         //获取项目路径和项目名
        const projectName = full_name.split("/")[1]
        const cmdStr = process.platform.indexOf('win') !== -1 ? `./index.sh ${projectName} ${clone_url}` : `sh ./index.sh ${projectName} ${clone_url}`
        exec(cmdStr, option, function (err, stdout, stderr) {
            if (err) {
                console.log('get weather api error:' + stderr);
            } else {
                console.log("更新代码成功")
            }
        });
        ctx.body = 'dddd'
    } catch (error) {
        console.log(error)
    }
    // await ctx.render('index');
})

app.use(router.routes()).use(router.allowedMethods());

app.listen('5555', () =&gt; {
    console.log('http://127.0.0.1:5555')
})</code></pre><p><font color="#f9963b">当我们提交代码是触发相应的hooks，然后再我们的请求接口中利用child_process模块</font></p><p><font color="#f9963b">去执行shell脚本做到自动拉取代码</font></p><h2 id="f43n1">2. 利用上述接口在相应得git项目中设置hooks钩子</h2><p>&nbsp; &nbsp;&nbsp;<br/></p><img src="https://www.azjfeng.com/static/hooks.png" contenteditable="false"/><h2 id="ns24d">3. 编写对应得shell脚本</h2><p><font color="#f9963b">&nbsp; &nbsp; $1 对应项目名 $2对应git地址</font><br/></p><pre><code class="Bash">#!/bin/bash

echo "/data/home/git/$1"
url = "/data/home/git/$1"
if [ ! -f $url ];then
    echo "文件不存在"
    cd /data/home/git/
    git clone "$2"
else
    echo '$1'
    cd /data/home/git/"$1"
    git pull
fi</code></pre>
<nil>
[GIN] 2022/04/15 - 15:42:26 | 200 |     558.311µs |   113.108.77.58 | POST     "/common/getDetail"
<nil>
[GIN] 2022/04/15 - 15:42:53 | 200 |     359.238µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/20 - 14:58:59 | 200 |   13.909004ms |   66.249.70.117 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/22 - 10:36:37 | 200 |     625.829µs |   66.249.70.117 | POST     "/common/getTechnologyShare"
[GIN] 2022/04/24 - 18:22:10 | 404 |       3.035µs | 183.240.111.153 | GET      "/"
<nil>
[GIN] 2022/04/29 - 16:01:25 | 200 |     615.479µs |   66.249.75.242 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/04/29 - 16:46:11 | 200 |     616.281µs |   66.249.75.246 | POST     "/common/getTechnologyShare"
[GIN] 2022/05/01 - 12:38:08 | 404 |       4.218µs |   103.40.114.82 | GET      "/common/template/lottery/lecai/css/style.css"
<nil>
[GIN] 2022/05/02 - 11:36:36 | 200 |     586.774µs |    171.13.14.47 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/04 - 18:20:16 | 200 |     623.585µs |    40.77.202.52 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/04 - 18:20:16 | 200 |     198.303µs |    40.77.202.52 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:47:28 | 200 |     594.699µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:48:37 | 200 |     360.288µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:48:42 | 200 |     362.283µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:48:50 | 200 |     821.868µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:49:02 | 200 |     376.209µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:49:30 | 200 |     357.022µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/05 - 17:53:24 | 200 |      690.26µs |   113.108.77.58 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/06 - 15:31:13 | 200 |     604.699µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/06 - 15:31:25 | 200 |      450.98µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/05/06 - 15:31:26 | 200 |  104.170117ms |   113.108.77.65 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/06 - 16:04:39 | 200 |     628.184µs |   113.108.77.65 | POST     "/common/getTechnologyShare"
<h2 id="yhxvr">1. 搭建服务端</h2><p>&nbsp; &nbsp; &nbsp; 可以利用nginx加上node和koa实现一个小型服务端</p><pre><code class="JavaScript">const Koa = require('koa');
const app = new Koa();
const Router = require('koa-router');
const router = new Router();
const koaBody = require('koa-body');
const path = require('path')
app.use(koaBody({
    multipart: true, // 支持文件上传
    formidable: {
        uploadDir: path.join(__dirname, 'public/upload/'), // 设置文件上传目录
        keepExtensions: true,    // 保持文件的后缀
        maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
        onFileBegin: (name, file) =&gt; { // 文件上传前的设置
            // console.log(`name: ${name}`);
            // console.log(file);
        },
    }
}));

<font color="#1c487f">const exec = require('child_process').exec;</font>

let temp = process.env,
    environment = {};
environment.PATH = temp.PATH + ":/usr/local/node/bin";
const option = {
    env: environment
}
console.log(process.platform)

router.post('/api/gitpull', async (ctx, next) =&gt; {
    try {
        const params = JSON.parse(ctx.request.body.payload)             //获取github请求参数
        const { repository: { clone_url, full_name } } = params         //获取项目路径和项目名
        const projectName = full_name.split("/")[1]
        const cmdStr = process.platform.indexOf('win') !== -1 ? `./index.sh ${projectName} ${clone_url}` : `sh ./index.sh ${projectName} ${clone_url}`
        exec(cmdStr, option, function (err, stdout, stderr) {
            if (err) {
                console.log('get weather api error:' + stderr);
            } else {
                console.log("更新代码成功")
            }
        });
        ctx.body = 'dddd'
    } catch (error) {
        console.log(error)
    }
    // await ctx.render('index');
})

app.use(router.routes()).use(router.allowedMethods());

app.listen('5555', () =&gt; {
    console.log('http://127.0.0.1:5555')
})</code></pre><p><font color="#f9963b">当我们提交代码是触发相应的hooks，然后再我们的请求接口中利用child_process模块</font></p><p><font color="#f9963b">去执行shell脚本做到自动拉取代码</font></p><h2 id="f43n1">2. 利用上述接口在相应得git项目中设置hooks钩子</h2><p>&nbsp; &nbsp;&nbsp;<br/></p><img src="https://www.azjfeng.com/static/hooks.png" contenteditable="false"/><h2 id="ns24d">3. 编写对应得shell脚本</h2><p><font color="#f9963b">&nbsp; &nbsp; $1 对应项目名 $2对应git地址</font><br/></p><pre><code class="Bash">#!/bin/bash

echo "/data/home/git/$1"
url = "/data/home/git/$1"
if [ ! -f $url ];then
    echo "文件不存在"
    cd /data/home/git/
    git clone "$2"
else
    echo '$1'
    cd /data/home/git/"$1"
    git pull
fi</code></pre>
<nil>
[GIN] 2022/05/07 - 11:52:52 | 200 |   10.472814ms |   113.108.77.73 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/07 - 17:29:00 | 200 |     644.754µs |   113.108.77.73 | POST     "/common/getTechnologyShare"
<h3 id="t2yj2"><font color="#8baa4a">一、如何将真实节点转换成json格式得数据</font></h3><div>&nbsp; &nbsp; <font color="#46acc8">&nbsp;通过dom api获取元素得nodetype，如果是元素节点就去获取对应的属性和对应的子节点，再通过递归将对应的子节点也转换成对应的json数据。如果是文本节点和注释就直接返回对应的json数据。</font><font color="#8baa4a"><br/></font></div><p>&nbsp; &nbsp;&nbsp;<br/></p><pre><code class="TypeScript"><xmp>function toVNode(node: Node, domApi?: DOMAPI): VNode {
    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
    let text: string;
    if (api.isElement(node)) {                            //判断是否元素节点
        const id = node.id ? "#" + node.id : "";            //获取节点上的ID属性
        const cn = node.getAttribute("class");              //获取节点上的Class
        const c = cn ? "." + cn.split(" ").join(".") : "";  //将获取到的class分割
        const sel = api.tagName(node).toLowerCase() + id + c; //将id和class与节点名称组合
        const attrs: any = {};                                //存储节点得自定义属性
        const children: VNode[] = [];                         //存储当前节点得所有子节点
        let name: string;
        let i: number, n: number;
        const elmAttrs = node.attributes;                 //获取除了id和class的其他属性
        const elmChildren = node.childNodes;              //获取获取子节点
        for (i = 0, n = elmAttrs.length; i &lt; n; i++) {
            name = elmAttrs[i].nodeName;
            if (name !== "id" &amp;&amp; name !== "class") {
                attrs[name] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i &lt; n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode(sel, { attrs }, children, undefined, node);
    } else if (api.isText(node)) {                            //判断是否文本节点
        text = api.getTextContent(node) as string;
        return vnode(undefined, undefined, undefined, text, node);
    } else if (api.isComment(node)) {                         //判断是否是注释
        text = api.getTextContent(node) as string;
        return vnode("!", {}, [], text, node as any);
    } else {
        return vnode("", {}, [], undefined, node as any);
    }
}</xmp></code></pre>
<nil>
[GIN] 2022/05/07 - 17:29:05 | 200 |   14.008812ms |   113.108.77.73 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/07 - 17:29:09 | 200 |      393.13µs |   113.108.77.73 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/05/07 - 17:29:11 | 200 |    22.55705ms |   113.108.77.73 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/07 - 17:29:34 | 200 |     353.958µs |   113.108.77.73 | POST     "/common/getTechnologyShare"
<h4>一、可选链接运算符【？.】</h4><p><strong>可选链接运算符（Optional Chaining Operator）</strong>&nbsp;处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。</p><p>相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：</p><pre><code class="JavaScript"><xmp>if (data && data.children && data.children[0] && data.children[0].title) {
    // I have a title!
} 
</xmp><xmp>consoel.log('aaa')</xmp></code></pre>
<nil>
[GIN] 2022/05/07 - 17:29:36 | 200 |   20.881624ms |   113.108.77.73 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/07 - 17:29:39 | 200 |     357.253µs |   113.108.77.73 | POST     "/common/getTechnologyShare"
<p>开发<code>webpack</code>插件需要知道的几个必要条件：</p><ul><li>获取编译器&nbsp;<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F" target="_blank">compiler</a>&nbsp;对象，通过这个对象能过获取包括config配置，资源文件，编译信息，钩子函数等信息</li><li>编译阶段的生命周期函数，找到适合的钩子函数处理对应逻辑</li><li>返回结果支持同步和异步两种方式</li></ul><h3>获取<code>compiler</code>实例</h3><p>第一步获取&nbsp;<code>compiler</code>&nbsp;实例对象：</p><pre><code class="Bash"><xmp>// helloPlugin.js
module.exports = class RemoveLogs {
    constructor(options){
        this.options = options
    }
    apply(compiler) {
        console.log(`Hello ${this.options.name}`)
    }
};</xmp></code></pre><h3 id="b8frm">生命周期阶段处理数据</h3><pre><code class="Bash"><xmp>
const fs = require('fs')
module.exports = class RemoveLogs {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        compiler.hooks.done.tap("RemoveLogs", stats => {
            const { path, filename } = stats.compilation.options.output;
            console.log(path, filename)
            try {
                // 这里可以做匹配到 filename 才做处理
                let filePath = path + "/" + filename;
                console.log(filePath)
                fs.readFile(filePath, "utf8", (err, data) => {
                    const rgx = /console.log\(['|"](.*?)['|"]\)/;
                    const newdata = data.replace(rgx, "");
                    if (err) console.log(err);
                    fs.writeFile(filePath, newdata, function (err) {
                        if (err) {
                            return console.log(err)
                        }
                        console.log("Logs Removed");
                    });
                });
            } catch (error) {
                console.log(error)
            }
        });
    }
};</xmp></code></pre><h3 id="ek9ad">webpack配置中引入插件</h3><pre><code class="Bash"><xmp>const RemoveLogs = require('./removelog.js')
module.exports = {
    entry:"./test.js",
    output:{
      filename:'main.js'
    },
    module: {
        rules: [
          {
            test: /\.(tsx|js|jsx)$/,
            use: ['babel-loader'],
            exclude: /node_modules/
          },
        ]
      },
      plugins: [new RemoveLogs({ name:"chenwl" })]
}</xmp></code></pre>
<nil>
[GIN] 2022/05/07 - 17:29:40 | 200 |    2.742625ms |   113.108.77.73 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/07 - 17:29:46 | 200 |     371.529µs |   113.108.77.73 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/07 - 21:42:44 | 200 |     673.818µs |  116.179.37.145 | POST     "/common/getTechnologyShare"
[GIN] 2022/05/14 - 21:17:59 | 404 |       3.948µs |   111.13.63.134 | GET      "/"
[GIN] 2022/05/14 - 21:18:22 | 404 |       2.986µs |    119.90.52.34 | GET      "/"
[GIN] 2022/05/14 - 21:18:22 | 404 |       2.925µs |    119.90.52.34 | GET      "/favicon.ico"
[GIN] 2022/05/14 - 21:18:22 | 404 |       2.755µs |    119.90.52.34 | GET      "//.well-known/security.txt"
[GIN] 2022/05/14 - 21:18:22 | 404 |       1.373µs |    119.90.52.34 | GET      "//robots.txt"
[GIN] 2022/05/14 - 21:18:22 | 404 |       1.313µs |    119.90.52.34 | GET      "//sitemap.xml"
<nil>
[GIN] 2022/05/15 - 04:52:33 | 200 |     643.773µs |   183.240.69.16 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/15 - 04:52:38 | 200 |     418.327µs |   183.240.69.16 | POST     "/common/getTechnologyShare"
<nil>
[GIN] 2022/05/15 - 10:08:20 | 200 |     776.302µs |  113.118.103.15 | POST     "/common/getTechnologyShare"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/05/15 - 10:08:33 | 200 |     536.702µs |  113.118.103.15 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/05/15 - 10:08:41 | 200 |     1.10393ms |  113.118.103.15 | POST     "/common/getDetail"
<h2 id="gsjkb">踩坑</h2><p>1. 同一个目录下的文件的package 包名必须一致</p><p><img src="https://tva3.sinaimg.cn/large/d030806aly1gxw35blavmj21jk2bjqus.jpg" alt="嘿嘿" contenteditable="false" width="100%"/></p><pre><code class="JavaScript"><xmp>package main

import "fmt"

const boilingF = 212.0

func main()  {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %F or %g\n", f, c)
	Function()
}</xmp></code></pre><pre><code class="JavaScript"><xmp>package main

import "fmt"

func Function(){
    fmt.Println("this main package, function func")
}</xmp></code></pre><p>2. 编译目录中的所有文件可以用 go run directory(目录名)或者使用go run ./ （windows）LInux可以使用 go run *.go</p>
<nil>
[GIN] 2022/05/15 - 10:08:46 | 200 |     613.775µs |  113.118.103.15 | POST     "/common/getDetail"
<nil>
[GIN] 2022/05/15 - 10:08:56 | 200 |     358.505µs |  113.118.103.15 | POST     "/common/getTechnologyShare"
